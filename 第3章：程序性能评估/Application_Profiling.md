# 3.1 Profile
现实中与有不少情况是：很多程序中的核心功能可能仅数十行或者数百行就得以实现了。使用程序性能分析工具，开发人员能够识别出这部分热点代码，并为该部分代码的并行化编制候选方案。

## 3.1.1 Creating the Profile
如今已经有许多可行的方式可以用于测试代码的性能，但总归，所有的方案最终目的都是一样的：即识别出应用程序中那些最耗时的函数或者函数们。

**高优先级**：为了最大化开发人员的开发价值，测试应用程序性能以找出热点代码和性能瓶颈。

翻译：任何性能分析动作最重要的考量都是确保工作负载是符合实际情况的，比如，在测试环节和决策环节所采纳的信息都应该是来自于真实场景的信息。采用虚假的数据会导致sub-optimal问题和让开发人员在和真实不符的问题边界以及非瓶颈的函数上浪费过多的时间。

有许多性能分析工具可以用来满足我们的需求，下文给出的是一个Linux平台下来源于GNU内建指令集的开源profiler：[gprof]
```bash
$ gcc -O2 -g -pg myprog.c
$ gprof ./a.out > profile.txt
Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ms/call  ms/call  name    
 33.34      0.02     0.02     7208     0.00     0.00  genTimeStep
 16.67      0.03     0.01      240     0.04     0.12  calcStats
 16.67      0.04     0.01        8     1.25     1.25  calcSummaryData
 16.67      0.05     0.01        7     1.43     1.43  write
 16.67      0.06     0.01                             mcount
  0.00      0.06     0.00      236     0.00     0.00  tzset
  0.00      0.06     0.00      192     0.00     0.00  tolower
  0.00      0.06     0.00       47     0.00     0.00  strlen
  0.00      0.06     0.00       45     0.00     0.00  strchr
  0.00      0.06     0.00        1     0.00    50.00  main
  0.00      0.06     0.00        1     0.00     0.00  memcpy
  0.00      0.06     0.00        1     0.00    10.11  print
  0.00      0.06     0.00        1     0.00     0.00  profil
  0.00      0.06     0.00        1     0.00    50.00  report
```

## 3.1.2 Identifying Hostpots
上边的例子中，一眼便可发现函数[genTimeStep]用时占据了应用程序总耗时的1/3。因此，这个函数应该作为我们程序并行化时首先需要考虑的函数。[Understanding Scaling]()小节会对我们进行并行化带来的潜在收益进行讨论。

对上述例子进一步分析可以发现，如[calcStats()]和[calcSummaryData()]函数也在程序用时上有相当的占比。对这些函数进行并行化的改写将释放我们的程序的加速潜能。然而，由于APOD是一个循环往复的过程，我们应该在随后的APOD流程中逐步并行化这些函数，以将我们工作的范围限定在局部，避免在一次APOD流程中对程序整体做大幅度的变更。

### 3.1.3 Understanding Scaling
应用程序在CUDA上运行时的性能完全取决于其并行化的程度。原则上来说，无法充分并行化的代码应该规划到host上运行，当然也有例外情况，就是这样做会导致host和device之间传输过多的数据，这种情况需要注意。

**High Priority**: 为了最大化发挥CUDA的性能，首先将注意力放到提升串行代码的并行度上。


